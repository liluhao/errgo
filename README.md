# errgo

## 介绍
针对go原生错误处理痛点，结合github.com/pkg/errors库（以下简称errors）优势，设计的一款错误处理组件。


## 抽象
整体优化主要从以下展开：
+ 对erors库生成的错误进行封装一层错误类型，用于定位该错误属于哪种类型的错误
+ errors库打印错误调用栈时会打印与业务代码无关的调用信息，而这些信息对开发者来说可能没有必要，所以在维持旧功能
前提下，调用栈信息只打印与业务有关的调用栈，使开发者更专注
+ 调用栈打印错误所在文件路径极长，影响阅读体验，在维持旧功能前提下，只从项目根目录开始打印调用栈，这个功能是可选的
+ wrap/wrapf 方法默认会在error struct中加入调用栈信息，这个时候，如果它的下层也使用wrap/wrapf 或 new/newf
时，打印栈信息则会打印多于两个调用栈信息，如何能在这种情况下，使得打印上下文信息，接着是两者之间的调用函数信息，然后
是上下文信息这种格式呢？我也有了一些思路，但是时间不够，带有时间就会把这个功能完善好。
+ 将错误定义统一放置在一个文件中


## 具体
errorGo里面的stack,errors是把github.com/pkg/errors 重写了2/3
（因为项目中用到的错误处理场景不多，我就只把用到的部分摘了下来同时改了改结构，
因为我最要做的是在他们上面封装了一层）.
目的是为了理解思想，逻辑。

stack里面的addFCByIF，funcname，profile是新加的，callers则做了修改，还有其他小地方也做了改动，
errors里面的ModifyPC是新写的。
还有就是对其中每一点和方法做了注解（英文：主要是练习英语），然后用TODO标记了下次优化的方向。

error_operation是新加的文件，在最外面封装了错误类型，同时把错误类型跟响应状态码结合了起来，
这样utils/app/response文件代码可以抽象为两到三个即可。通过这种方式即可根据具体错误类型选择对应的响应状态码。

code_message:这个文件则是把全文的错误信息汇总到一个地方，
在定义错误和control层判断错误也直接调用就可以。（在这一文件中分模块定义错误）

error_operation_test中的handleError方法作用是把之前control层判断错误这一块代码从逻辑中抽离出来，
用一个方法的形式处理各自模块的错误类型返回相应的业务状态码

## 联系

v：x15516535379